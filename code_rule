一、总则
1、清晰，易于维护：代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化。

2、简洁：代码简洁，提升可靠性：废弃的代码(没有被调用的函数和全局变量)要及时清除，重复代码应该尽可能提炼成函数。

3、风格统一

二、头文件

----对于C语言来说，头文件的设计体现了大部分的系统设计
----减少文件间的依赖：在一个设计良好的系统中，修改一个文件，只需要重新编译数个，甚至是一个文件。>>>>> 减少包含头文件，尤其是在头文件中包含头文件

1、头文件职责单一，不要过于复杂，尽量减少include其他头文件

2、头文件的依赖方向稳定>>>>产品依赖于平台（通用组件），平台（通用组件）依赖于标准库

3、每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。 如果一个.c文件不需要对外公布任何接口，则其就不应当存在>>>>>一旦把私有定义、声明放到独立的头 文件中，就无法从技术上避免别人include之，难以保证这些定义最后真的只是私有的。 

4、 禁止头文件循环依赖。

5、.c/.h文件禁止包含用不到的头文件

6、自包含就是任意一个头文件均可独立编译>>>就是说一个头文件不要包含另外头文件

7、编写内部#include保护符>>>>>所有头文件都应当使用#define 防止头文件被多重包含，命名格式为FILENAME_H，为了保证唯一性， 更好的命名是PROJECTNAME_PATH_FILENAME_H。  注：没有在宏最前面加上“_"，即使用FILENAME_H代替_FILENAME_H_，是因为一般以"_"和”__"开头的 标识符为系统保留或者标准库使用，在有些静态检查工具中，若全局可见的标识符以"_"开头会给出告警。 

示例：假定VOS工程的timer模块的timer.h，其目录为VOS/include/timer/timer.h,应按如下方式保护：
#ifndef VOS_INCLUDE_TIMER_TIMER_H  
#define VOS_INCLUDE_TIMER_TIMER_H  
...  
#endif
 
也可以使用如下简单方式保护:
#ifndef TIMER_H  
#define TIMER_H
 ..  
#endif 

8、禁止在头文件中定义变量。 

9、只能通过包含头文件的方式使用其他.c提供的接口

说明：若a.c使用了b.c定义的foo()函数，则应当在b.h中声明extern int foo(int input)；并在a.c 中通过#include <b.h>来使用foo。

10、同一产品统一包含头文件排列方式。 
常见的包含头文件排列方式：功能块排序、文件名升序、稳定度排序。 

三、函数
1、一个函数仅完成一件功能。>>>>realloc。在标准C语言中，realloc是一个典型的不良设计。

2、重复代码应该尽可能提炼成函数。

3、可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其 加以保护。
说明：可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是 多个任务可以共用此函数的必要条件。共享变量指的全局变量static变量。

4、对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责>>也就是需要注意对函数参数合法性检查。

5、对函数的错误返回码要全面处理

6、函数不变参数使用const。 
说明：不变的值更易于理解/跟踪和分析
int strncmp(const char *s1, const char *s2, register size_t n)

7、函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方应集中使用
集中使用比如我同事将内存申请放在一起，使用tlv方式来使用该段内存

8、检查函数所有非参数输入的有效性，如数据文件、公共变量等。 
说明：函数的输入主要有两种：一种是参数输入；另一种是全局变量、数据文件的输入，即非参数输 入。函数在使用输入参数之前，应进行有效性检查

9、函数的参数个数不超过5个。>>函数的参数个数不要超过5个，如果超过了建议拆分为不同函数。 

10、除打印类函数外，不要使用可变长参函数。 

四、标识符

1、除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音。
示例：一些常见可以缩写的例子：
argument 可缩写为 arg
buffer 可缩写为 buff
clock 可缩写为 clk
command 可缩写为 cmd
compare 可缩写为 cmp
configuration 可缩写为 cfg
device 可缩写为 dev
error 可缩写为 err
hexadecimal 可缩写为 hex
increment 可缩写为 inc、
initialize 可缩写为 init
maximum 可缩写为 max
message 可缩写为 msg
minimum 可缩写为 min
parameter 可缩写为 para
previous 可缩写为 prev
register 可缩写为 reg
semaphore 可缩写为 sem
statistic 可缩写为 stat
synchronize 可缩写为 sync
temp 可缩写为 tmp 

2、用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。 

示例：
add/remove           begin/end           create/destroy 
insert/delete        first/last          get/release
increment/decrement    put/get       add/delete        
lock/unlock          open/close     min/max          
old/new              start/stop    next/previous    
source/target        show/hide    send/receive      
source/destination    copy/paste          up/down 

3、尽量避免名字中出现数字编号，除非逻辑上的确需要编号。
4、变量命名规则
规则1 全局变量应增加“g_”前缀。
规则2 静态变量应增加“s_”前缀。 
变量命名不应采用匈牙利命名法，而应想法使变量名为一个有意义的词 或词组，方便代码的阅读。 
规则3 使用名词或者形容词＋名词方式命名变量。

5、函数命名规则
规则1 函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构。 

五、变量
1、一个变量只有一个功能，不能把一个变量用作多种用途。 

2、结构功能单一；不要设计面面俱到的数据结构>>> 结构的定义应该可以明确的描述一个对象，而不 是一组相关性不强的数据的集合。

3、通讯过程中使用的结构，必须注意字节序。 
对于这种跨平台的交互，数据成员发送前，都应该进行主机序到网络序的转换；接收时，也必须进行 网络序到主机序的转换。 

4、 严禁使用未经初始化的变量作为右值（符号右边的）。 

5、构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止 多个不同模块或函数都可以修改、创建同一全局变量的现象。>>降低全局变量耦合度。

6、 使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供 接口函数来设置、获取，同时注意全局数据的访问互斥。  
说明：避免直接暴露内部数据给外部模型使用，是防止模块间耦合最简单有效的方法。 

7、在首次使用前初始化变量，初始化的地方离使用的地方越近越好。 

8、尽量减少没有必要的数据类型默认转换与强制转换。 

六、宏，常量

1、用宏定义表达式时，要使用完备的括号

2、将宏所定义的多条表达式放在大括号中>>>>更好的方法是多条语句写成do while(0)的方式。

3、使用宏时，不允许参数发生变化

示例：如下用法可能导致错误。
#define SQUARE(a) ((a) * (a))
int a = 5;
int b;
b = SQUARE(a++); // 结果：a = 7，即执行了两次增。
 
正确的用法是：
b = SQUARE(a);
a++; // 结果：a = 6，即只执行了一次增。 

4、不允许直接使用魔鬼数字
说明：使用魔鬼数字的弊端：代码难以理解；如果一个有含义的数字多处使用，一旦需要修改这个数 值，代价惨重。 
解决途径：
对于局部使用的唯一含义的魔鬼数字，可以在代码周围增加说明注释，也可以定义局部const变量，变 量命名自注释。  
对于广泛使用的数字，必须定义const全局变量/宏；同样变量/宏命名应是自注释的。
0作为一个特殊的数字，作为一般默认值使用没有歧义时，不用特别定义。

5、除非必要，应尽可能使用函数代替宏。 
6、常量建议使用const定义代替宏。 
定义一个常量：
const double ASPECT_RATIO = 1.653;
这种方法很有效，但有两个特殊情况要注意。首先，定义指针常量时会有点不同。因为常量定义一般 是放在头文件中（许多源文件会包含它），除了指针所指的类型要定义成const外，重要的是指针也经 常要定义成const。例如，要在头文件中定义一个基于char*的字符串常量，你要写两次const：  
const char * const authorName = "Scott Meyers"; 

7、宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。

七、质量保证
1、必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如 局部变量在何处分配、静态变量在何处分配等

2、禁止内存操作越界
3、禁止内存泄漏
坚持下列措施可以避免内存泄漏：
  异常出口处检查内存、定时器/文件句柄/Socket/队列/信号量/GUI等资源是否全部释放
  删除结构指针时，必须从底层向上层顺序删除
  使用指针数组时，确保在释放数组时，数组中的每个元素指针是否已经提前被释放了
  避免重复分配内存  
  小心使用有return、break语句的宏，确保前面资源已经释放
  检查队列中每个成员是否释放

4、禁止引用已经释放的内存空间 
坚持下列措施可以避免引用已经释放的内存空间：
  内存释放后，把指针置为NULL；使用内存指针前进行非空判断。
  耦合度较强的模块互相调用时，一定要仔细考虑其调用关系，防止已经删除的对象被再次使用。
  避免操作已发送消息的内存。
  自动存储对象的地址不应赋值给其他的在第一个对象已经停止存在后仍然保持的对象（具有更 大作用域的对象或者静态对象或者从一个函数返回的对象） 

5、编程时，要防止差1错误>>>此类错误一般是由于把“<=”误写成“<”或“>=”误写成“>”等造成的

6、所有的if ... else if结构应该由else子句结束 ；switch语句必须有default分支。

7、不要滥用goto语句
可以利用goto语句方面退出多重循环；同一个函数体内部存在大量相同的逻辑但又不方便封装成函数 的情况下，譬如反复执行文件操作，对文件操作失败以后的处理部分代码（譬如关闭文件句柄，释放 动态申请的内存等等），一般会放在该函数体的最后部分，再需要的地方就goto到那里，这样代码反 而变得清晰简洁。

8、时刻注意表达式是否会上溢、下溢
示例：如下程序将造成变量下溢。
unsigned char size ;
…
while (size-- >= 0) // 将出现下溢 ，因为无符号，所以木有负值
{
    ... // program code
}
当size等于0时，再减不会小于0，而是0xFF，故程序是一个死循环。应如下修改。
char size; // 从unsigned char 改为char
…
while (size-- >= 0)
{
    ... // program code
}

八、执行效率
1、代码效率提升>>应该把执行概 率较大的分支放在前面处理
int foo()  
{  
    if (满足条件)  
    {  
        正常处理;  
        return SUCCESS;  
    }  
    else if (概率比较大的异常条件)  
    {  
        异常处理;
        return ERR_CODE_1;  
    }  
    else  
    {  
        异常处理;
        return ERR_CODE_2;  
    }  
} 

2、通过对数据结构、程序算法的优化来提高效率。
2.1、将不变条件的计算移到循环体外
2.2、对于多维大数组，避免来回跳跃式访问数组成员
2.3、创建资源库，以减少分配对象的开销>>如线程池，内存池等

3、将多次被调用的 “小函数”改为inline函数或者宏实现
说明： 如果编译器支持inline，可以采用inline函数。否则可以采用宏。
在做这种优化的时候一定要注意下面inline函数的优点：其一编译时不用展开，代码SIZE小。其二可 以加断点，易于定位问题，例如对于引用计数加减的时候。其三函数编译时，编译器会做语法检查。 三思而后行。 

九、表达式
1、表达式的值在标准所允许的任何运算次序下都应该是相同的
函数参数
说明：函数参数通常从右到左压栈，但函数参数的计算次序不一定与压栈次序相同。
函数指针  
说明：函数参数和函数自身地址的计算次序未定义。

2、函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利。 
说明：如下代码不合理，仅用于说明当函数作为参数时，由于参数压栈次数不是代码可以控制的，可
能造成未知的输出：
int g_var;  
int fun1()  
{  
    g_var += 10;  
    return g_var;  
}  
 
int fun2()  
{
g_var += 100;  
    return g_var;  
}  
int main(int argc, char *argv[], char *envp[])  
{  
    g_var = 1;  
    printf("func1: %d, func2: %d\n", fun1(), fun2());  
 
    g_var = 1;  
    printf("func2: %d, func1: %d\n", fun2(), fun1());  
} 

3、赋值语句不要写在if等语句中，或者作为函数的参数使用。 

4、使用断言记录内部假设，不能用断言来检查运行时错误。 
说明：断言是对某种内部模块的假设条件进行检查，如果假设不成立，说明存在编程、设计错误。断 言可以对在系统中隐藏很深，用其它手段极难发现的问题进行定位，从而缩短软件问题定位时间，提 高系统的可测性。 
断言的使用是有条件的。断言只能用于程序内部逻辑的条件判断，而不能用于对外部输入数据的判断 ，因为在网上实际运行时，是完全有可能出现外部输入非法数据的情况。 

十、安全性
1、对用户输入进行检查
可采取以下措施对用户输入检查：
  用户输入作为数值的，做数值范围检查
  用户输入是字符串的，检查字符串长度
  用户输入作为格式化字符串的，检查关键字“%”
  用户输入作为业务数据，对关键字进行检查、转义 

2、确保所有字符串是以NULL结束
为了避免缓冲区溢出，常常会用相对安全的限制字符数量的字符串操作函数代替一些危险函数。如：
  用strncpy()代替strcpy()
  用strncat()代替strcat()
  用snprintf()代替sprintf()
  用fgets()代替gets() 
示例：
char a[16];
strncpy(a, "0123456789abcdef", sizeof(a));
上述代码存在安全风险：在调用strncpy()后，字符数组a中的字符串是没有NULL结束符的，也没有空
间存放NULL结束符。
正确写法：截断字符串，保证字符串以NULL结束。
char a[16];
strncpy(a, "0123456789abcdef", sizeof(a) - 1 );
a[sizeof(a) - 1] = '\0';

3、不要将边界不明确的字符串写到固定长度的数组中。 
正确写法：计算字符串的实际长度，使用malloc分配指定长度的内存

4、避免整数溢出
说明：当一个整数被增加超过其最大值时会发生整数上溢，被减小小于其最小值时会发生整数下溢。 带符号和无符号的数都有可能发生溢出。 
示例1：有符号和无符号整数的上溢和下溢
int i;
unsigned int j;
 
i = INT_MAX; // 2,147,483,647
i++; 
printf("i = %d\n", i);  // i=-2,147,483,648
 
j = UINT_MAX; // 4,294,967,295;
j++;
printf("j = %u\n", j);  // j = 0
 
i = INT_MIN; // -2,147,483,648;
i--;
printf("i = %d\n", i);  // i = 2,147,483,647
 
j = 0;
j--;
printf("j = %u\n", j);  // j = 4,294,967,295 

5、 避免符号错误
带符号整型转换到无符号整型，最高位（high-order bit）会丧失其作为符号位的功能。如果该带符 号整数的值非负，那么转换后值不变；如果该带符号整数的值为负，那么转换后的结果通常是一个非 常大的正数。 

6、避免截断错误
说明：将一个较大整型转换为较小整型，并且该数的原值超出较小类型的表示范围，就会发生截断错 误，原值的低位被保留而高位被丢弃。截断错误会引起数据丢失

7、 避免将用户输入作为格式化字符串的一部分或者全部
说明：调用格式化I/O函数时，不要直接或者间接将用户输入作为格式化字符串的一部分或者全部。攻 击者对一个格式化字符串拥有部分或完全控制，存在以下风险：进程崩溃、查看栈的内容、改写内存、 甚至执行任意代码。
示例1：
char input[1000];
if (fgets(input, sizeof(input) - 1, stdin) == NULL)  
{
    /* handle error */
}
input[sizeof(input)-1] = '\0';
printf(input);
 
上述代码input直接来自用户输入，并作为格式化字符串直接传递给printf()。当用户输入的是 “%s%s%s%s%s%s%s%s%s%s%s%s”，就可能触发无效指针或未映射的地址读取。
正确做法：给printf()传两个参数，第一个参数为”%s”，目的是将格式化字符串确定下来；第二个参
数为用户输入input。
char input[1000];
if (fgets(input, sizeof(input)-1, stdin) == NULL)  
{
    /* handle error */
}
input[sizeof(input)-1] = '\0';
printf(“%s”, input); 

8、避免使用strlen()计算二进制数据的长度
说明：strlen()函数用于计算字符串的长度，它返回字符串中第一个NULL结束符之前的字符的数量。 因此用strlen()处理文件I/O函数读取的内容时要小心，因为这些内容可能是二进制也可能是文本。
示例：
char buf[BUF_SIZE + 1]; 
if (fgets(buf, sizeof(buf), fp) == NULL)  
{
    /* handle error */
}
buf[strlen(buf) - 1] = '\0';    
上述代码试图从一个输入行中删除行尾的换行符（\n）。如果buf的第一个字符是NULL，strlen(buf) 返回0，这时对buf进行数组下标为[-1]的访问操作将会越界。  
正确做法：在不能确定从文件读取到的数据的类型时，不要使用依赖NULL结束符的字符串操作函数。
char buf[BUF_SIZE + 1];
char *p;
if (fgets(buf, sizeof(buf), fp))  
{
    p = strchr(buf, '\n');
    if (p)  
    {
        *p = '\0';
    }
}
else
{
    /* handle error condition */
}

9、使用int类型变量来接受字符I/O函数的返回值
说明：字符I/O函数fgetc()、getc()和getchar()都从一个流读取一个字符，并把它以int值的形式返 回。如果这个流到达了文件尾或者发生读取错误，函数返回EOF。fputc()、putc()、putchar()和ungetc() 也返回一个字符或EOF。 如果这些I/O函数的返回值需要与EOF进行比较，不要将返回值转换为char类型。因为char是有符号8 位的值，int是32位的值。如果getchar()返回的字符的ASCII值为0xFF，转换为char类型后将被解释为 EOF。因为这个值被有符号扩展为0xFFFFFFFF（EOF的值）执行比较
